<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>SQL Server Table Partitioning in Large Scale Data Warehouse 3 - Herman-blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Icaurs - Hexo Theme"><meta name="msapplication-TileImage" content="/img/favicon1.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Icaurs - Hexo Theme"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="This post is the last part on series of table partitioning, as plan this part is going to focus on some advanced topics like partition merge, split, conversion and performance optimization in terms of"><meta property="og:type" content="blog"><meta property="og:title" content="SQL Server Table Partitioning in Large Scale Data Warehouse 3"><meta property="og:url" content="https://hermanteng19.github.io/2021/01/01/SQL-Server-Table-Partitioning-in-Large-Scale-Data-Warehouse-3/"><meta property="og:site_name" content="Herman-blog"><meta property="og:description" content="This post is the last part on series of table partitioning, as plan this part is going to focus on some advanced topics like partition merge, split, conversion and performance optimization in terms of"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://hermanteng19.github.io/img/partitionmergeribbon.jpg"><meta property="article:published_time" content="2021-01-01T22:54:55.000Z"><meta property="article:modified_time" content="2023-07-05T01:40:35.880Z"><meta property="article:author" content="Herman Teng"><meta property="article:tag" content="SQL Server"><meta property="article:tag" content="partitioning"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/partitionmergeribbon.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hermanteng19.github.io/2021/01/01/SQL-Server-Table-Partitioning-in-Large-Scale-Data-Warehouse-3/"},"headline":"Herman-blog","image":["https://hermanteng19.github.io/img/partitionmergeribbon.jpg"],"datePublished":"2021-01-01T22:54:55.000Z","dateModified":"2023-07-05T01:40:35.880Z","author":{"@type":"Person","name":"Herman Teng"},"description":"This post is the last part on series of table partitioning, as plan this part is going to focus on some advanced topics like partition merge, split, conversion and performance optimization in terms of"}</script><link rel="canonical" href="https://hermanteng19.github.io/2021/01/01/SQL-Server-Table-Partitioning-in-Large-Scale-Data-Warehouse-3/"><link rel="icon" href="/img/favicon1.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.2.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar1.png" alt="Herman-blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/img/partitionmergeribbon.jpg" alt="SQL Server Table Partitioning in Large Scale Data Warehouse 3"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-01-01T22:54:55.000Z" title="2021-01-01T22:54:55.000Z">2021-01-01</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-07-05T01:40:35.880Z" title="2023-07-05T01:40:35.880Z">2023-07-04</time></span><span class="level-item"><a class="link-muted" href="/categories/Database/">Database</a><span> / </span><a class="link-muted" href="/categories/Database/BI/">BI</a></span><span class="level-item">16 minutes read (About 2474 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">SQL Server Table Partitioning in Large Scale Data Warehouse 3</h1><div class="content"><p>This post is the last part on series of table partitioning, as plan this part is going to focus on some advanced topics like partition merge, split, conversion and performance optimization in terms of different business demands.</p>
<p>The first thing we will talk about might be interesting, we know one benefit of table partitioning is speed up loading and archiving data, we can easily feel the performance improvement on query against large data after table partitioning, but data archiving is not that apparent and it’s on the lower file system level to helps you mange data more on the backend efficiently by file group and database file. After all, we are intent to manage data through partitions and additionally, manage partitions through database files, but that is not that straight forward.</p>
<a id="more"></a>

<h2 id="Efficient-way-to-manage-partition-using-database-file-group-and-file"><a href="#Efficient-way-to-manage-partition-using-database-file-group-and-file" class="headerlink" title="Efficient way to manage partition using database file group and file"></a>Efficient way to manage partition using database file group and file</h2><p>We might suppose out data would be stored like below if table is partitioned by month:</p>
<ul>
<li>January -&gt; partition number 1</li>
<li>February -&gt; partition number 2</li>
<li>…</li>
<li>November -&gt; partition number 11</li>
<li>December -&gt; partition number 12</li>
</ul>
<p>The similar situation on daily partition:</p>
<ul>
<li>Day 1 -&gt; partition number 1</li>
<li>Day 2 -&gt; partition number 2</li>
<li>…</li>
<li>Day 29 -&gt; partition number 29</li>
<li>Day 30 -&gt; partition number 30</li>
<li>Day 31-&gt; partition number 31</li>
</ul>
<p>Let’s assume we have daily transaction table currently has 31 partitions for each month, which is supposed to store daily data to corresponding partition in terms of partition number (1 to 31) and we also create 31 database files under the same file group (one file group for each month), which is supposed to have connection to their corresponding partitions in terms of file number (1 to 31).</p>
<p>but, the question is that is data really saved in partition as above pattern showed? and Is partition number really associated with corresponding database file?</p>
<p>The answer is no, actually the data will evenly spread to all partitions and each database file associates with all partitions. But how come we say table partitioning is the good way to mange our data and data file, the solution is <strong>file group</strong>.</p>
<ul>
<li>Create multiple file groups in stead of single file group<ul>
<li>Manage monthly partition data, we can create 12 file groups for each month with number 1 to 12 instead of one single file group with suffix of year. E.g. <ol>
<li>Create file group <code>BUSINESS_DB_FG_TRANS_202001...202012</code></li>
<li>Don’t create file group ‘BUSINESS_DB_FG_TRANS_2020`</li>
</ol>
</li>
</ul>
</li>
<li>Create single database file under its corresponding file group.<ul>
<li>Manga monthly partition data, we can only create single data file under each file group <ol>
<li>Create <code>BUSINESS_DB_F_TRANS_202001</code> under file group <code>BUSINESS_DB_FG_TRANS_202001</code></li>
</ol>
</li>
</ul>
</li>
<li>Create partition scheme which will carry the partition function to associate with file group</li>
</ul>
<p>In this way, data will be loaded into the right file group and right database file, in another word, we can say January 2020 data is allocated at database file <code>BUSINESS_DB_F_TRANS_202001</code> under the file group <code>BUSINESS_DB_FG_TRANS_202001</code> </p>
<p>Above all, multiple file groups and single file mode, which is the efficient way to manage data, we can assign initial, auto growth and limited size in terms of daily or monthly data volume. If we keep single file group for daily or monthly partition table, we can create any number of files as long as assign the right initial, auto growth and limited size number, but we lose control from physical data management point of view.</p>
<h2 id="Partitions-merge-split-and-use-case-for-dealing-with-transaction-data-rollup"><a href="#Partitions-merge-split-and-use-case-for-dealing-with-transaction-data-rollup" class="headerlink" title="Partitions merge, split and use case for dealing with transaction data rollup"></a>Partitions merge, split and use case for dealing with transaction data rollup</h2><p>In this selection, we talk about partition merge and split, actually, they are technics of data management. In production, we either merge partitions or split them in according to data storage and management needs, let’s assume we have daily transaction table with 365 partitions for each year, now think about do you want to keep that mange partitions or you want to rollup to a monthly partition table so that there are only 12 partitions in each year, obviously, in most of case, we choose rollup transaction data into monthly partition table because that is much easier to maintain partitions such as yearly partition expansion for future year data allocation.</p>
<p>In another side, what if we get a big chunk of data such as 5 years sales and order data, do you want to keep this big volume data or you want to split it by year or month into different partition, apparently, it’s more efficient to partition table by year or month.</p>
<p>Now, let’s see how do we apply partition merge to daily transaction data rollup.</p>
<h3 id="Basic-setups-before-daily-partition-merge-into-monthly-partition"><a href="#Basic-setups-before-daily-partition-merge-into-monthly-partition" class="headerlink" title="Basic setups before daily partition merge into monthly partition"></a>Basic setups before daily partition merge into monthly partition</h3><p>In this use case, we need two partition tables, one is daily partition table we named it <code>trans_current</code>, it has below setups</p>
<ul>
<li><p>file group: BUSINESS_DB_FG_TRANS_2020</p>
</li>
<li><p>partition function: BUSINESS_DB_PF_TRANS_CURRENT</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">partition</span> <span class="keyword">function</span> BUSINESS_DB_PF_TRANS_CURRENT </span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">range</span> <span class="keyword">left</span> <span class="keyword">values</span> (<span class="number">20200101</span>, <span class="number">20200102</span>,...,<span class="number">20201230</span>,<span class="number">20201231</span>) <span class="keyword">go</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>partition scheme: BUSINESS_DB_PS_TRANS_CURRENT</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">partition</span> scheme BUSINESS_DB_PS_TRANS_CURRENT </span><br><span class="line"><span class="keyword">as</span> <span class="keyword">partition</span> BUSINESS_DB_PF_TRANS_CURRENT <span class="keyword">to</span> </span><br><span class="line">(BUSINESS_DB_FG_TRANS_2020,...,BUSINESS_DB_FG_TRANS_2020)</span><br></pre></td></tr></table></figure>

<p>the another table is monthly partition table, its name is <code>trans</code>, it has below setups</p>
<ul>
<li><p>file group: BUSINESS_DB_FG_TRANS_2020</p>
</li>
<li><p>partition function: BUSINESS_DB_PF_TRANS</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">partition</span> <span class="keyword">function</span> BUSINESS_DB_PF_TRANS</span><br><span class="line"><span class="keyword">as</span> <span class="keyword">range</span> <span class="keyword">left</span> <span class="keyword">for</span> <span class="keyword">values</span> (<span class="number">20200131</span>, <span class="number">20200228</span>,...,<span class="number">20201130</span>,<span class="number">20201231</span>) <span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<p>We will do the partition switching after merge so that the partition function of monthly table set up like above as the last day of month to be boundary value.</p>
</li>
<li><p>partition scheme: BUSINESS_DB_PS_TRANS</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">partition</span> scheme BUSINESS_DB_PS_TRANS </span><br><span class="line"><span class="keyword">as</span> <span class="keyword">partition</span> BUSINESS_DB_PF_TRANS <span class="keyword">to</span> </span><br><span class="line">(BUSINESS_DB_FG_TRANS_2020,...,BUSINESS_DB_FG_TRANS_2020)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="Workflow-of-partition-merge-and-switching"><a href="#Workflow-of-partition-merge-and-switching" class="headerlink" title="Workflow of partition merge and switching"></a>Workflow of partition merge and switching</h3><p>In order to reduce the down time in production, we don’t merge partition on daily transaction table but we first partition switch to a middle temp table <code>switch</code> table then do the partition merge on that, finally switch partition to monthly transaction table.</p>
<p><img src="/img/screenshots/partitionmerge.png" alt="partitionmerge.png"></p>
<h3 id="Partition-merge-and-switching"><a href="#Partition-merge-and-switching" class="headerlink" title="Partition merge and switching"></a>Partition merge and switching</h3><p>As workflow chart shows, we use previous part code to firstly create switch table in terms of <code>trans_currsnt</code> table structure then switch 30 (31) partitions for one month to switch table, now switch table contains the whole month transaction data evenly allocated into daily partitions, it’s time for us to merge daily partition into one (the last day of the month) then switch to transaction monthly table.</p>
<p>Before that, we need to bear in mind that we have to disable <code>columnstore</code> index then rebuild  it after partition merge if you use SQL Server 2014 or order version, we use SQL Server 2012 so we need to do that.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> business_db</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">index</span> CIS_TRANS_CURRENT <span class="keyword">ON</span> dbo.TRANS_CURRENT <span class="keyword">disable</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> business_db</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">index</span> CIS_TRANS_CURRENT <span class="keyword">ON</span> dbo.TRANS_CURRENT <span class="keyword">enable</span></span><br></pre></td></tr></table></figure>

<p>create a functional stored procedure for partition merging in general cases</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> business_db</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> dbo.usp_mergePartitions</span><br><span class="line">(</span><br><span class="line">	@table_name <span class="built_in">varchar</span>(<span class="number">100</span>)</span><br><span class="line">    ,@start_boundary <span class="built_in">int</span></span><br><span class="line">    ,@end_boundary <span class="built_in">int</span></span><br><span class="line">    ,@fisc_month_start <span class="built_in">int</span></span><br><span class="line">    ,@partition_interval</span><br><span class="line">    ,@dbname <span class="built_in">varchar</span>(<span class="number">100</span>)=<span class="string">&#x27;business_db&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">as</span> </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> @sp_msg <span class="built_in">varchar</span>(<span class="number">100</span>)</span><br><span class="line">,@rangeBoundary <span class="built_in">int</span></span><br><span class="line"><span class="keyword">begin</span> try</span><br><span class="line"><span class="keyword">begin</span> trans</span><br><span class="line"><span class="comment">--check some input variable values</span></span><br><span class="line"><span class="keyword">set</span> @table_name=<span class="keyword">ltrim</span>(<span class="keyword">rtrim</span>(@table_name))</span><br><span class="line"><span class="keyword">if</span>(@table_name=<span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> @table_name <span class="keyword">is</span> <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">set</span> @sp_msg=<span class="string">&#x27;end up with @table_name empty, check input values&#x27;</span></span><br><span class="line"><span class="keyword">goto</span> errorProc</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">declare</span> @sSQL <span class="built_in">varchar</span>(<span class="keyword">max</span>)</span><br><span class="line">,@irange <span class="built_in">int</span></span><br><span class="line">,@fisc_month_end <span class="built_in">int</span></span><br><span class="line">,@pf_name <span class="built_in">varchar</span>(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">set</span> pf_name=@db_name+<span class="string">&#x27;_PF_&#x27;</span>+@table_name</span><br><span class="line"><span class="keyword">set</span> @sParam=<span class="string">&#x27;@rangeOut int output&#x27;</span></span><br><span class="line"><span class="keyword">set</span> @irange=@start_boundary</span><br><span class="line"><span class="keyword">set</span> @fisc_month_end=(<span class="keyword">abs</span>(@fisc_month_start<span class="number">-1</span>)+@partition_interval)%@partition_interval</span><br><span class="line"><span class="keyword">while</span>(@irange&lt;@end_boundary)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">set</span> @sSQL=<span class="string">&#x27;use &#x27;</span>+@db_name+<span class="string">&#x27;; select @rangeOut=cast(value as int) from</span></span><br><span class="line"><span class="string">sys.partition_range_values as prv inner join sys.partition_functions as pfs</span></span><br><span class="line"><span class="string">on prv.function_id=pfs.function_id where pfs.name=&#x27;&#x27;&#x27;</span>+@pf_name+<span class="string">&#x27;&#x27;&#x27; and</span></span><br><span class="line"><span class="string">boundary_id=$partition.&#x27;</span>+@pf_name+<span class="string">&#x27;(&#x27;</span>+<span class="keyword">convert</span>(<span class="built_in">char</span>(<span class="number">8</span>),@irange)+<span class="string">&#x27;)&#x27;</span></span><br><span class="line">exec sp_executeSQL @sSQL, @sParam, @rangeOut=@rangeBoundary <span class="keyword">output</span></span><br><span class="line"><span class="keyword">if</span> @irange=@rangeBoundary</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">set</span> @sSQL=<span class="string">&#x27;use &#x27;</span>+@db_name+<span class="string">&#x27;; alter partition function &#x27;</span>+@pf_name+<span class="string">&#x27;()&#x27;</span>+</span><br><span class="line"><span class="string">&#x27; merge range( &#x27;</span>+<span class="keyword">convert</span>(<span class="built_in">char</span>(<span class="number">8</span>),@irange)+<span class="string">&#x27;)&#x27;</span></span><br><span class="line">exec sp_executeSQL @sSQL</span><br><span class="line"><span class="comment">--dim_calendar is a common time table, day_key is 8 digits integer YYYYMMDD like 20200101</span></span><br><span class="line"><span class="keyword">select</span> @irange=a.day_key <span class="keyword">from</span> dim_calendar <span class="keyword">as</span> a</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> dim_calendar <span class="keyword">as</span> b <span class="keyword">on</span> a.daycounter=b.daycounter+<span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> b.day_key=@irange</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">commit</span> trans</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span> try</span><br><span class="line"><span class="keyword">begin</span> catch</span><br><span class="line"><span class="keyword">rollback</span></span><br><span class="line"><span class="comment">--add some try catch block statement</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">end</span> catch</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>Now, we create an API to pass the data to stored procedure based on our example </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> business_db</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> trans_partiton_merging</span><br><span class="line"><span class="keyword">as</span> </span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line"><span class="keyword">declare</span> @return_result <span class="built_in">int</span></span><br><span class="line"><span class="keyword">begin</span> try</span><br><span class="line"><span class="keyword">select</span> top <span class="number">1</span> @date_key=load_dt/<span class="number">100</span> <span class="keyword">from</span> staging.dbo.trans_current</span><br><span class="line"><span class="keyword">if</span> @date_key%<span class="number">100</span>&gt;<span class="number">1</span></span><br><span class="line"><span class="keyword">set</span> @date_key=@date_key<span class="number">-1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">set</span> @date_key=@date_key<span class="number">-89</span></span><br><span class="line"><span class="keyword">select</span> @rrange=<span class="keyword">max</span>(day_key),@lrange=<span class="keyword">min</span>(day_key)</span><br><span class="line"><span class="keyword">from</span> business_db.dbo.dim_calendar </span><br><span class="line"><span class="keyword">where</span> month_key=@date_key</span><br><span class="line">exec @return_result=business_db.dbo.sp_mergePartitions @table_name=<span class="string">&#x27;switch_trans&#x27;</span></span><br><span class="line">,@start_boundary=@lrange</span><br><span class="line">,@end_boundary=@rrange</span><br><span class="line">,@partition_interval=<span class="number">1</span></span><br><span class="line">,@dbname=<span class="string">&#x27;business_db&#x27;</span></span><br><span class="line"><span class="keyword">if</span>(@return_result&lt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="comment">--add some log statement</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span> try</span><br><span class="line"><span class="keyword">begin</span> catch</span><br><span class="line"><span class="comment">--add some try catch block statement</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">end</span> catch</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>There is only one partition left for January 2020 after partition merge whose boundary value is 20200131 so that we can partition switch to monthly table (detail reference previous post).</p>
<h2 id="Table-type-conversion-—-a-more-efficient-way-to-handle-transaction-data-rollup"><a href="#Table-type-conversion-—-a-more-efficient-way-to-handle-transaction-data-rollup" class="headerlink" title="Table type conversion —- a more efficient way to handle transaction data rollup"></a>Table type conversion —- a more efficient way to handle transaction data rollup</h2><p>You might think the partition merge is complicated and what performance benefit you can gain by this technology. Actually, partition merge performance is not ideal, depends on how big data size in your partition, the partition merge may take a quit a long time to conduct, 50 columns and  100mm records data roughly takes 3 hours, so the question is is there any another way to do the same task but with simpler and more efficient approach, the answer is <strong>yes</strong>,  table partitioning technology provides us another potential way to “merge partitions” with more than 10 times increase on performance. </p>
<p>The main idea is convert switch table from partition table to non partition table then partition switching from non partition table to target partition table (details for partition switching reference previous post).</p>
<h3 id="Use-create-clustered-index-clause-to-rebuild-clustered-index"><a href="#Use-create-clustered-index-clause-to-rebuild-clustered-index" class="headerlink" title="Use create clustered index clause to rebuild clustered index"></a>Use <code>create clustered index</code> clause to rebuild clustered index</h3><p>It’s kind of wired, anything of creating clustered index is related with our topic, it looks not, but it does, I found that just by chance, when I rebuild clustered index for partitioned table using <code>with drop_existing</code>, I suddenly realized that the partitioned table become non partitioned table with new clustered index setup. The good thing is that step is really fast, as I mentioned 50 columns and 100mm records partitioned table only takes 15 minutes to become non partitioned table.</p>
<p><img src="/img/screenshots/elapsedtime_nonpartitionalized.png" alt="elapsedtime_nonpartitionalized.png"></p>
<p>you can know from below screenshot, switch table from partitioned table become non partition table by <code>table property</code> dialogue box</p>
<p><img src="/img/screenshots/tableproperty.png" alt="tableproperty.png"></p>
<p>below is the reason why <code>with drop_existing</code> statement is fast from <a target="_blank" rel="noopener" href="https://www.itprotoday.com/author/brian-moran">Brian Moran</a> post.</p>
<blockquote>
<p>Changing your clustered indexes by using the CREATE INDEX statement’s DROP_EXISTING clause is faster. The DROP_EXISTING clause tells SQL Server that the existing clustered index is being dropped but that a new one will be added in its place, letting SQL Server defer updating the nonclustered index until the new clustered index is in place. (Note that you can use DBCC DBREINDEX to rebuild existing indexes because it won’t cause SQL Server to rebuild a nonclustered index. But you can’t use DBCC DBREINDEX to change the columns in an existing index.) With DROP_EXISTING, you save one complete cycle of dropping and recreating nonclustered indexes. Additionally, SQL Server won’t rebuild the nonclustered index at all if the clustered index key doesn’t change and is defined as UNIQUE, which isn’t an obvious performance benefit of defining a clustered index as UNIQUE. Using the DROP_EXISTING clause can be a huge time-saver when you need to change the clustered index on a table that also has nonclustered indexes.</p>
</blockquote>
<h3 id="Workflow-of-non-partitionalize-and-partition-switching"><a href="#Workflow-of-non-partitionalize-and-partition-switching" class="headerlink" title="Workflow of non partitionalize and partition switching"></a>Workflow of non partitionalize and partition switching</h3><p>The central idea for the process is use partition switch for every data load both on partition switching from daily transaction table to switch table and from switch table to target transaction monthly table, which promises the best performance.</p>
<p><img src="/img/screenshots/nonpartition.png" alt="nonpartition.png"></p>
<p>Now, let’s see how do we convert switch table to non partition table</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> business_db</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> dbo.switchTrans_nonpartition</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">begin</span> try</span><br><span class="line"><span class="keyword">declare</span> @filegroup <span class="built_in">varchar</span>(<span class="number">100</span>)</span><br><span class="line">,@month_key <span class="built_in">int</span></span><br><span class="line">,@sSQL <span class="built_in">varchar</span>(<span class="keyword">max</span>)</span><br><span class="line">,@sParam <span class="built_in">varchar</span>(<span class="number">100</span>)</span><br><span class="line">,@processFY <span class="built_in">varchar</span>(<span class="number">6</span>)</span><br><span class="line">,@sp_msg <span class="built_in">varchar</span>(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> top <span class="number">1</span> @month_key=month_key <span class="keyword">from</span> switch_trans</span><br><span class="line"><span class="keyword">set</span> @sSQL=<span class="string">&#x27;select @fyOUt=fiscalYear from business_db.dbo.dim_calendar where</span></span><br><span class="line"><span class="string">where month_key=&#x27;</span>+<span class="keyword">convert</span>(<span class="built_in">char</span>(<span class="number">6</span>),@month_key)+<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">set</span> @sParam=<span class="string">&#x27;@fyOut varchar(10) output&#x27;</span></span><br><span class="line">exec sp_executeSQL @sSQL, @sParam, @fyOut=processFY <span class="keyword">output</span></span><br><span class="line"><span class="keyword">select</span> @filegroup=<span class="string">&#x27;BUSINESS_DB_FG_TRANS_&#x27;</span>+@processFY</span><br><span class="line"><span class="keyword">set</span> @sSQL=<span class="string">&#x27;</span></span><br><span class="line"><span class="string">create clustered index PK_SWITCH_TRANS ON business_db.dbo.switch_trans</span></span><br><span class="line"><span class="string">(month_key,trans_id,trans_dt)</span></span><br><span class="line"><span class="string">with drop_existing on</span></span><br><span class="line"><span class="string">&#x27;</span>+@filegroup</span><br><span class="line">exec sp_executeSQL @sSQL</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span> try</span><br><span class="line"><span class="keyword">begin</span> catch</span><br><span class="line"><span class="comment">--add some tray catch blog statement</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>next step is quite essential which is set up check constraints for non partitioned switch table because by partition switch syntax the database engine does partition switching from one source partition number to one target partition number, so check constraint just like a simulation of partition number to let database engine treats it as one partition.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> business_db</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> switch_trans_constraint</span><br><span class="line"><span class="keyword">as</span> </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">begin</span> try</span><br><span class="line"><span class="keyword">declare</span> @month_key <span class="built_in">int</span></span><br><span class="line">,@lrange <span class="built_in">int</span></span><br><span class="line">,@sSQL <span class="built_in">varchar</span>(<span class="keyword">max</span>)</span><br><span class="line">,@sp_msg <span class="built_in">varchar</span>(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">select</span> top <span class="number">1</span> @month_key=month_key <span class="keyword">from</span> dbo.switch_trans</span><br><span class="line"><span class="keyword">if</span> @month_key%<span class="number">100</span>&gt;<span class="number">1</span></span><br><span class="line"><span class="keyword">set</span> @lrange=@month_key<span class="number">-1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">set</span> @lrange=@month_key<span class="number">-89</span></span><br><span class="line"><span class="keyword">if</span> OBJECT_ID(<span class="string">&#x27;ckMinMonth_key&#x27;</span>,<span class="string">&#x27;C&#x27;</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line"><span class="keyword">after</span> <span class="keyword">table</span> business_db.dbo.switch_trans </span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">constraint</span> ckMinMonth_key</span><br><span class="line"><span class="keyword">if</span> OBJECT_ID(<span class="string">&#x27;ckMaxMonth_key&#x27;</span>,<span class="string">&#x27;C&#x27;</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line"><span class="keyword">after</span> <span class="keyword">table</span> business_db.dbo.switch_trans </span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">constraint</span> ckMaxMonth_key</span><br><span class="line"><span class="keyword">set</span> @sSQL=<span class="string">&#x27;</span></span><br><span class="line"><span class="string">after table business_db.dbo.switch_trans</span></span><br><span class="line"><span class="string">with check add constraint ckMaxMonth_key</span></span><br><span class="line"><span class="string">check (month_key is not null and month_key&gt;&#x27;</span>+</span><br><span class="line"><span class="keyword">convert</span>(<span class="built_in">varchar</span>(<span class="number">6</span>),<span class="string">&#x27;&#x27;</span>+@lrange+<span class="string">&#x27;&#x27;</span>)+<span class="string">&#x27;);&#x27;</span>+<span class="string">&#x27;</span></span><br><span class="line"><span class="string">after table business_db.dbo.switch_trans</span></span><br><span class="line"><span class="string">with check add constraint ckMaxMonth_key</span></span><br><span class="line"><span class="string">check (month_key is not null and month_key&lt;=&#x27;</span></span><br><span class="line">+<span class="keyword">convert</span>(<span class="built_in">varchar</span>(<span class="number">6</span>),<span class="string">&#x27;&#x27;</span>+@month_key+<span class="string">&#x27;&#x27;</span>)+<span class="string">&#x27;);&#x27;</span></span><br><span class="line"></span><br><span class="line">exec sp_executeSQL @sSQL;</span><br><span class="line">return 0</span><br><span class="line"><span class="keyword">end</span> try</span><br><span class="line"><span class="keyword">begin</span> catch</span><br><span class="line"><span class="comment">--add some catch block statement</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">end</span> catch</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>next, we need to rebuild <code>columnstore</code> index for switch table in order to keep the index structure as the same as target transaction table, finally switch partition to target table. You can see we convert switch table from partition table to non partition table instead of partition merging, which only takes 15 minutes instead of 3 hours so that process performance is highly improved.</p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/SQL-Server/">SQL Server</a><a class="link-muted mr-2" rel="tag" href="/tags/partitioning/">partitioning</a></div><div class="a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a><a class="a2a_button_facebook"></a><a class="a2a_button_twitter"></a><a class="a2a_button_telegram"></a><a class="a2a_button_whatsapp"></a><a class="a2a_button_reddit"></a></div><script src="https://static.addtoany.com/menu/page.js" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/01/08/Increase-Disk-Space-for-Linux-Virtual-Machine-Created-by-VMware/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Increase Disk Space for Linux Virtual Machine Created by VMware</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/12/26/SQL-Server-Table-Partitioning-in-Large-Scale-Data-Warehouse-2/"><span class="level-item">SQL Server Table Partitioning in Large Scale Data Warehouse 2</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://hermanteng19.github.io/2021/01/01/SQL-Server-Table-Partitioning-in-Large-Scale-Data-Warehouse-3/';
            this.page.identifier = '2021/01/01/SQL-Server-Table-Partitioning-in-Large-Scale-Data-Warehouse-3/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'herman-hexo-blog' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar1.png" alt="Herman"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Herman</p><p class="is-size-6 is-block">Data Analyst&amp;Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Toronto, Canada</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">23</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">8</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">64</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/HermanTeng19" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/HermanTeng19"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Efficient-way-to-manage-partition-using-database-file-group-and-file"><span class="level-left"><span class="level-item">1</span><span class="level-item">Efficient way to manage partition using database file group and file</span></span></a></li><li><a class="level is-mobile" href="#Partitions-merge-split-and-use-case-for-dealing-with-transaction-data-rollup"><span class="level-left"><span class="level-item">2</span><span class="level-item">Partitions merge, split and use case for dealing with transaction data rollup</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Basic-setups-before-daily-partition-merge-into-monthly-partition"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">Basic setups before daily partition merge into monthly partition</span></span></a></li><li><a class="level is-mobile" href="#Workflow-of-partition-merge-and-switching"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">Workflow of partition merge and switching</span></span></a></li><li><a class="level is-mobile" href="#Partition-merge-and-switching"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">Partition merge and switching</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Table-type-conversion-—-a-more-efficient-way-to-handle-transaction-data-rollup"><span class="level-left"><span class="level-item">3</span><span class="level-item">Table type conversion —- a more efficient way to handle transaction data rollup</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Use-create-clustered-index-clause-to-rebuild-clustered-index"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">Use create clustered index clause to rebuild clustered index</span></span></a></li><li><a class="level is-mobile" href="#Workflow-of-non-partitionalize-and-partition-switching"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">Workflow of non partitionalize and partition switching</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar1.png" alt="Herman-blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 Herman Teng</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>